// deno-lint-ignore-file no-this-alias
// Dependencies

import * as math from './math.ts';

// Types

export enum flags {
  RIGHT = 0b00000001,
  BOTTOM_RIGHT = 0b00000010,
  BOTTOM = 0b00000100,
  BOTTOM_LEFT = 0b00001000,
  LEFT = 0b00010000,
  TOP_LEFT = 0b00100000,
  TOP = 0b01000000,
  TOP_RIGHT = 0b10000000,
}


export declare namespace Matrix {
  interface Coordinates {
    x: number,
    y: number
  }
  interface CoordinateLike {
    x: string | number,
    y: string | number
  }
  interface Value {
    x: number,
    y: number,
    value: unknown
  }
}

/**
 * @callback Matrix~Loop
 * @param {*} value the value at the coordinates
 * @param {Matrix~CoordsObject} coords the coordinates object
 * @param {Matrix} matrix the matrix
 */
export interface Loop {
  value: unknown,
  coords: Matrix.Coordinates,
  matrix: Matrix
}

type MatrixRow = Array<unknown>;
type Axis = 'x' | 'y';

// Private

function validateCoords(coords: Matrix.CoordinateLike): Matrix.Coordinates | null {
  const { x, y } = coords;
  const parsedX = typeof x === "string" ? parseInt(x, 10) : x;
  const parsedY = typeof y === "string" ? parseInt(y, 10) : y;

  if (
    parsedX !== Number(x) ||
    parsedY !== Number(y) ||
    parsedX < 0 ||
    parsedY < 0
  ) {
    return null;
  }

  return {
    x: parsedX,
    y: parsedY,
  };
}

// Public

export function translateCoords(coords: [number, number] | Matrix.Coordinates | string): Matrix.Coordinates {
  let result;
  if (Array.isArray(coords)) {
    const [x, y] = coords;
    result = { x, y };
  } else if (typeof coords === 'string') {
    const [x, y] = coords.split(',');
    result = { x, y };
  } else {
    const { x, y } = coords;
    result = { x, y };
  }

  const validated = validateCoords(result);
  return (validated === null) ? { x: -1, y: -1 } : validated;
}

export class Matrix {
  data: Array<MatrixRow>;
  defaultValue: unknown;

  constructor(data: Array<string> | Array<MatrixRow> = [], { processItem = (item: string) => parseInt(item, 10) } = {}, defaultValue: unknown | null = -1) {
    // Convert incoming data to a 2 dimensional array
    this.data = [...data].map((row: string) => [...row].map(processItem));
    this.defaultValue = defaultValue;
  }

  /**
   * @param {Matrix~Loop} fn
   */
  forEach(fn: (value: unknown, coords: Matrix.Coordinates, self: Matrix) => undefined) {
    const self = this;
    const rows = this.data;
    rows.forEach((row, y) => {
      row.forEach((val, x) => {
        fn(val, { x, y }, self);
      });
    });
  }

  map(fn: (value: unknown, coords: Matrix.Coordinates, self: Matrix) => Array<MatrixRow>) {
    const { width } = this;

    for (let y = 0; y < this.data.length; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const currentValue = this.get({ x, y });
        const newValue = fn(currentValue, { x, y }, this);
        this.set({ x, y }, newValue, false);
      }
    }

    return this.data;
  }

  reduce(fn: (previousValue: unknown, value: unknown, coords: Matrix.Coordinates, self: Matrix) => unknown, initialValue: unknown): unknown {
    const self = this;
    const flattened = this.data
      .map((rows, y) => rows.map((val, x) => ({ val, x, y })))
      .flat();

    return flattened.reduce(
      (previousValue, { val, x, y }) => fn(previousValue, val, { x, y }, self),
      initialValue
    );
  }

  get length() {
    // total number of elements
    return this.data.reduce((count, row) => {
      if (!Array.isArray(row)) {
        return count;
      }

      const validEntries = row.filter(
        (entry) => entry !== undefined && entry !== null
      );
      return count + Object.keys(validEntries).length;
    }, 0);
  }

  get width() {
    // length of the longest row
    return this.data.reduce((widest, row) => Math.max(widest, row.length), 0);
  }

  get height() {
    // number of rows
    return this.data.length;
  }

  get(coords: Matrix.Coordinates): Matrix.Value  {
    const { x, y } = translateCoords(coords);

    const value = this?.data?.[y]?.[x] ?? this.defaultValue;

    return { x, y, value };
  }

  set(coords: Matrix.Coordinates, value: unknown, mustExist = true): Matrix {
    const { x, y } = translateCoords(coords);

    if (x < 0 || y < 0 || x === undefined || y === undefined) {
      return this;
    }

    if (mustExist && (this?.data?.[y]?.[x] ?? 'DNE') === 'DNE') {
      return this;
    }

    this.data[y] = this.data?.[y] ?? [];
    this.data[y][x] = value;

    return this;
  }

  getAdjacents(
    coords: Matrix.Coordinates,
    { includeDiagonals = false, includeDirections = 0 } = {}
  ) {
    const self = this;
    const { x, y } = translateCoords(coords);
    const adjacents = [];

    let directions;

    // Only set if directions weren't specifically given
    if (includeDirections > 0) {
      directions = includeDirections;
    } else {
      directions = flags.RIGHT + flags.BOTTOM + flags.LEFT + flags.TOP;

      if (includeDiagonals) {
        directions +=
          flags.BOTTOM_RIGHT +
          flags.BOTTOM_LEFT +
          flags.TOP_LEFT +
          flags.TOP_RIGHT;
      }
    }

    if (directions & flags.RIGHT) {
      adjacents.push(this.get({ x: x + 1, y }));
    }
    if (directions & flags.BOTTOM) {
      adjacents.push(this.get({ x, y: y + 1 }));
    }
    if (directions & flags.LEFT) {
      adjacents.push(this.get({ x: x - 1, y }));
    }
    if (directions & flags.TOP) {
      adjacents.push(this.get({ x, y: y - 1 }));
    }
    if (directions & flags.BOTTOM_RIGHT) {
      adjacents.push(this.get({ x: x + 1, y: y + 1 }));
    }
    if (directions & flags.BOTTOM_LEFT) {
      adjacents.push(this.get({ x: x - 1, y: y + 1 }));
    }
    if (directions & flags.TOP_LEFT) {
      adjacents.push(this.get({ x: x - 1, y: y - 1 }));
    }
    if (directions & flags.TOP_RIGHT) {
      adjacents.push(this.get({ x: x + 1, y: y - 1 }));
    }

    return adjacents
      .filter(({ x: fx, y: fy }) => (self?.data?.[fy]?.[fx] ?? 'DNE') !== 'DNE')
      .map((c) => self.get(c));
  }

  flip({ axis = 'y', height = this.height } = {}) {
    if (axis === 'x') {
      const { width } = this;
      this.data = this.data.map((row) => {
        // eslint-disable-next-line no-param-reassign
        row[width - 1] = row[width - 1] || null;
        row.fill(null, row.length, width - 1);
        return row.reverse();
      });
    } else if (axis === 'y') {
      this.data[height - 1] = this.data[height - 1] || [];
      for (let i = 0; i < height; i += 1) {
        this.data[i] = this.data[i] || [];
      }
      this.data.reverse();
    }
    return this;
  }

  split(axis: Axis = 'x', index = 0, includeSplit = true): Matrix {
    const result = (axis === 'x') ? this.data.map((row) =>
      row.slice(includeSplit ? index : index + 1)
    ) : this.data.slice(includeSplit ? index : index + 1);

    this.data = (axis === 'x') ? this.data.map((row) => row.slice(0, index)) : this.data.slice(0, index);
   
    return new Matrix(result, { processItem: (item) => item });
  }

  merge(matrix: Matrix, fn = (_currentValue: unknown, incomingValue: unknown) => incomingValue) {
    const self = this;
    matrix.forEach((incomingValue, coords) => {
      const currentValue = self.get(coords, { defaultValue: null });
      const newValue = fn(currentValue, incomingValue);
      self.set(coords, newValue, { mustExist: false });
    });

    return this;
  }

  transpose() {
    this.data = math.transpose(this.data);
    return this;
  }

  toJSON() {
    return {
      Matrix: this.data,
    };
  }

  join({ joinX = '', joinY = '\n' } = {}) {
    return this.data.map((row) => row.join(joinX)).join(joinY);
  }
}